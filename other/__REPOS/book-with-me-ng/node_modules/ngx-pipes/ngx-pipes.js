import { NgModule, Pipe } from '@angular/core';

class DiffPipe {
    /**
     * @param {?} input
     * @param {...?} args
     * @return {?}
     */
    transform(input, ...args) {
        if (!Array.isArray(input)) {
            return input;
        }
        // tslint:disable-next-line no-bitwise
        return args.reduce((d, c) => d.filter((e) => !~c.indexOf(e)), input);
    }
}
DiffPipe.decorators = [
    { type: Pipe, args: [{ name: 'diff' },] },
];
/**
 * @nocollapse
 */
DiffPipe.ctorParameters = () => [];

class InitialPipe {
    /**
     * @param {?} input
     * @param {?=} num
     * @return {?}
     */
    transform(input, num = 0) {
        return Array.isArray(input)
            ? input.slice(0, input.length - num)
            : input;
    }
}
InitialPipe.decorators = [
    { type: Pipe, args: [{ name: 'initial' },] },
];
/**
 * @nocollapse
 */
InitialPipe.ctorParameters = () => [];

class FlattenPipe {
    /**
     * @param {?} input
     * @param {?=} shallow
     * @return {?}
     */
    transform(input, shallow = false) {
        if (!Array.isArray(input)) {
            return input;
        }
        return shallow
            ? [].concat.apply([], input)
            : this.flatten(input);
    }
    /**
     * @param {?} array
     * @return {?}
     */
    flatten(array) {
        return array.reduce((arr, elm) => {
            if (Array.isArray(elm)) {
                return arr.concat(this.flatten(elm));
            }
            return arr.concat(elm);
        }, []);
    }
}
FlattenPipe.decorators = [
    { type: Pipe, args: [{ name: 'flatten' },] },
];
/**
 * @nocollapse
 */
FlattenPipe.ctorParameters = () => [];

class IntersectionPipe {
    /**
     * @param {?} input
     * @param {...?} args
     * @return {?}
     */
    transform(input, ...args) {
        if (!Array.isArray(input)) {
            return input;
        }
        // tslint:disable-next-line no-bitwise
        return args.reduce((n, c) => n.filter((e) => !!~c.indexOf(e)), input);
    }
}
IntersectionPipe.decorators = [
    { type: Pipe, args: [{ name: 'intersection' },] },
];
/**
 * @nocollapse
 */
IntersectionPipe.ctorParameters = () => [];

/**
 * @param {?} value
 * @return {?}
 */
function isUndefined(value) {
    return typeof value === 'undefined';
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * @param {?} value
 * @return {?}
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return value !== null && typeof value === 'object';
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumberFinite(value) {
    return isNumber(value) && isFinite(value);
}
/**
 * @param {?} num
 * @param {?} precision
 * @return {?}
 */
function applyPrecision(num, precision) {
    if (precision <= 0) {
        return Math.round(num);
    }
    const /** @type {?} */ tho = Math.pow(10, precision);
    return Math.round(num * tho) / tho;
}
/**
 * @param {?} obj
 * @param {?} map
 * @return {?}
 */
function extractDeepPropertyByMapKey(obj, map) {
    const /** @type {?} */ keys = map.split('.');
    const /** @type {?} */ head = keys.shift();
    return keys.reduce((prop, key) => {
        return !isUndefined(prop) && !isUndefined(prop[key])
            ? prop[key]
            : undefined;
    }, obj[head || '']);
}
/**
 * @param {?} obj
 * @param {?} other
 * @return {?}
 */
function getKeysTwoObjects(obj, other) {
    return [...Object.keys(obj), ...Object.keys(other)]
        .filter((key, index, array) => array.indexOf(key) === index);
}
/**
 * @param {?} obj
 * @param {?} other
 * @return {?}
 */
function isDeepEqual(obj, other) {
    if (!isObject(obj) || !isObject(other)) {
        return obj === other;
    }
    return getKeysTwoObjects(obj, other).every((key) => {
        if (!isObject(obj[key]) && !isObject(other[key])) {
            return obj[key] === other[key];
        }
        if (!isObject(obj[key]) || !isObject(other[key])) {
            return false;
        }
        return isDeepEqual(obj[key], other[key]);
    });
}

class ReversePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        if (isString(input)) {
            return input.split('').reverse().join('');
        }
        return Array.isArray(input)
            ? input.slice().reverse()
            : input;
    }
}
ReversePipe.decorators = [
    { type: Pipe, args: [{ name: 'reverse' },] },
];
/**
 * @nocollapse
 */
ReversePipe.ctorParameters = () => [];

class TailPipe {
    /**
     * @param {?} input
     * @param {?=} num
     * @return {?}
     */
    transform(input, num = 0) {
        return Array.isArray(input) ? input.slice(num) : input;
    }
}
TailPipe.decorators = [
    { type: Pipe, args: [{ name: 'tail' },] },
];
/**
 * @nocollapse
 */
TailPipe.ctorParameters = () => [];

class TrurthifyPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return Array.isArray(input)
            ? input.filter(e => !!e)
            : input;
    }
}
TrurthifyPipe.decorators = [
    { type: Pipe, args: [{ name: 'truthify' },] },
];
/**
 * @nocollapse
 */
TrurthifyPipe.ctorParameters = () => [];

class UnionPipe {
    /**
     * @param {?} input
     * @param {?=} args
     * @return {?}
     */
    transform(input, args = []) {
        if (!Array.isArray(input) || !Array.isArray(args)) {
            return input;
        }
        return args.reduce((newArr, currArr) => {
            return newArr.concat(currArr.reduce((noDupArr, curr) => {
                // tslint:disable-next-line:no-bitwise
                return (!~noDupArr.indexOf(curr) && !~newArr.indexOf(curr))
                    ? noDupArr.concat([curr])
                    : noDupArr;
            }, []));
        }, input);
    }
}
UnionPipe.decorators = [
    { type: Pipe, args: [{ name: 'union' },] },
];
/**
 * @nocollapse
 */
UnionPipe.ctorParameters = () => [];

class UniquePipe {
    /**
     * @param {?} input
     * @param {?=} propertyName
     * @return {?}
     */
    transform(input, propertyName) {
        const /** @type {?} */ uniques = [];
        return Array.isArray(input) ?
            isUndefined(propertyName) ?
                input.filter((e, i) => input.indexOf(e) === i) :
                input.filter((e, i) => {
                    let /** @type {?} */ value = extractDeepPropertyByMapKey(e, propertyName);
                    value = isObject(value) ? JSON.stringify(value) : value;
                    if (isUndefined(value) || uniques[value]) {
                        return false;
                    }
                    uniques[value] = true;
                    return true;
                }) : input;
    }
}
UniquePipe.decorators = [
    { type: Pipe, args: [{ name: 'unique' },] },
];
/**
 * @nocollapse
 */
UniquePipe.ctorParameters = () => [];

class WithoutPipe {
    /**
     * @param {?} input
     * @param {?=} args
     * @return {?}
     */
    transform(input, args = []) {
        return Array.isArray(input)
            ? input.filter(e => !~args.indexOf(e))
            : input;
    }
}
WithoutPipe.decorators = [
    { type: Pipe, args: [{ name: 'without' },] },
];
/**
 * @nocollapse
 */
WithoutPipe.ctorParameters = () => [];

class PluckPipe {
    /**
     * @param {?} input
     * @param {?} map
     * @return {?}
     */
    transform(input, map) {
        return Array.isArray(input)
            ? input.map(e => extractDeepPropertyByMapKey(e, map))
            : input;
    }
}
PluckPipe.decorators = [
    { type: Pipe, args: [{ name: 'pluck', pure: false },] },
];
/**
 * @nocollapse
 */
PluckPipe.ctorParameters = () => [];

class ShufflePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        if (!Array.isArray(input)) {
            return input;
        }
        const /** @type {?} */ shuffled = [...input];
        const /** @type {?} */ n = input.length - 1;
        for (let /** @type {?} */ i = 0; i < n; ++i) {
            const /** @type {?} */ j = Math.floor(Math.random() * (n - i + 1)) + i;
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }
}
ShufflePipe.decorators = [
    { type: Pipe, args: [{ name: 'shuffle' },] },
];
/**
 * @nocollapse
 */
ShufflePipe.ctorParameters = () => [];

class EveryPipe {
    /**
     * @param {?} input
     * @param {?} predicate
     * @return {?}
     */
    transform(input, predicate) {
        return Array.isArray(input) ? input.every(predicate) : false;
    }
}
EveryPipe.decorators = [
    { type: Pipe, args: [{ name: 'every' },] },
];
/**
 * @nocollapse
 */
EveryPipe.ctorParameters = () => [];

class SomePipe {
    /**
     * @param {?} input
     * @param {?} predicate
     * @return {?}
     */
    transform(input, predicate) {
        return Array.isArray(input) ? input.some(predicate) : input;
    }
}
SomePipe.decorators = [
    { type: Pipe, args: [{ name: 'some' },] },
];
/**
 * @nocollapse
 */
SomePipe.ctorParameters = () => [];

class SamplePipe {
    /**
     * @param {?} input
     * @param {?=} len
     * @return {?}
     */
    transform(input, len = 1) {
        if (!Array.isArray(input)) {
            return input;
        }
        let /** @type {?} */ sample = [];
        const /** @type {?} */ tmp = [...input];
        const /** @type {?} */ l = len < tmp.length ? len : tmp.length;
        for (let /** @type {?} */ i = 0; i < l; ++i) {
            sample = sample.concat(tmp.splice(Math.floor(Math.random() * tmp.length), 1));
        }
        return sample;
    }
}
SamplePipe.decorators = [
    { type: Pipe, args: [{ name: 'sample' },] },
];
/**
 * @nocollapse
 */
SamplePipe.ctorParameters = () => [];

class GroupByPipe {
    /**
     * @param {?} input
     * @param {?=} discriminator
     * @param {?=} delimiter
     * @return {?}
     */
    transform(input, discriminator = [], delimiter = '|') {
        if (!Array.isArray(input)) {
            return input;
        }
        return this.groupBy(input, discriminator, delimiter);
    }
    /**
     * @param {?} list
     * @param {?} discriminator
     * @param {?} delimiter
     * @return {?}
     */
    groupBy(list, discriminator, delimiter) {
        return list.reduce((acc, payload) => {
            const /** @type {?} */ key = this.extractKeyByDiscriminator(discriminator, payload, delimiter);
            acc[key] = Array.isArray(acc[key])
                ? acc[key].concat([payload])
                : [payload];
            return acc;
        }, {});
    }
    /**
     * @param {?} discriminator
     * @param {?} payload
     * @param {?} delimiter
     * @return {?}
     */
    extractKeyByDiscriminator(discriminator, payload, delimiter) {
        if (isFunction(discriminator)) {
            return ((discriminator))(payload);
        }
        if (Array.isArray(discriminator)) {
            return discriminator.map(k => extractDeepPropertyByMapKey(payload, k)).join(delimiter);
        }
        return extractDeepPropertyByMapKey(payload, /** @type {?} */ (discriminator));
    }
}
GroupByPipe.decorators = [
    { type: Pipe, args: [{ name: 'groupBy' },] },
];
/**
 * @nocollapse
 */
GroupByPipe.ctorParameters = () => [];

class FilterByPipe {
    /**
     * @param {?} input
     * @param {?} props
     * @param {?=} search
     * @param {?=} strict
     * @return {?}
     */
    transform(input, props, search = '', strict = false) {
        if (!Array.isArray(input) || (!isString(search) && !isNumberFinite(search) && !isBoolean(search))) {
            return input;
        }
        const /** @type {?} */ term = String(search).toLowerCase();
        return input.filter((obj) => {
            return props.some((prop) => {
                const /** @type {?} */ value = extractDeepPropertyByMapKey(obj, prop);
                const /** @type {?} */ strValue = String(value).toLowerCase();
                if (isUndefined(value)) {
                    return false;
                }
                return strict
                    ? term === strValue
                    : !!~strValue.indexOf(term);
            });
        });
    }
}
FilterByPipe.decorators = [
    { type: Pipe, args: [{ name: 'filterBy' },] },
];
/**
 * @nocollapse
 */
FilterByPipe.ctorParameters = () => [];

class OrderByPipe {
    /**
     * @param {?} input
     * @param {?=} config
     * @return {?}
     */
    transform(input, config) {
        if (!Array.isArray(input)) {
            return input;
        }
        const /** @type {?} */ out = [...input];
        // sort by multiple properties
        if (Array.isArray(config)) {
            return out.sort((a, b) => {
                const /** @type {?} */ l = config.length;
                for (let /** @type {?} */ i = 0; i < l; ++i) {
                    const [prop, asc] = OrderByPipe.extractFromConfig(config[i]);
                    const /** @type {?} */ pos = OrderByPipe.orderCompare(prop, asc, a, b);
                    if (pos !== 0) {
                        return pos;
                    }
                }
                return 0;
            });
        }
        // sort by a single property value
        if (isString(config)) {
            const [prop, asc, sign] = OrderByPipe.extractFromConfig(config);
            if (config.length === 1) {
                // tslint:disable-next-line:switch-default
                switch (sign) {
                    case '+': return out.sort(OrderByPipe.simpleSort.bind(this));
                    case '-': return out.sort(OrderByPipe.simpleSort.bind(this)).reverse();
                }
            }
            return out.sort(OrderByPipe.orderCompare.bind(this, prop, asc));
        }
        // default sort by value
        return out.sort(OrderByPipe.simpleSort.bind(this));
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static simpleSort(a, b) {
        return isString(a) && isString(b)
            ? a.toLowerCase().localeCompare(b.toLowerCase())
            : a - b;
    }
    /**
     * @param {?} prop
     * @param {?} asc
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static orderCompare(prop, asc, a, b) {
        const /** @type {?} */ first = extractDeepPropertyByMapKey(a, prop);
        const /** @type {?} */ second = extractDeepPropertyByMapKey(b, prop);
        if (first === second) {
            return 0;
        }
        if (isUndefined(first) || first === '') {
            return 1;
        }
        if (isUndefined(second) || second === '') {
            return -1;
        }
        if (isString(first) && isString(second)) {
            const /** @type {?} */ pos = first.toLowerCase().localeCompare(second.toLowerCase());
            return asc ? pos : -pos;
        }
        return asc
            ? first - second
            : second - first;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    static extractFromConfig(config) {
        const /** @type {?} */ sign = config.substr(0, 1);
        const /** @type {?} */ prop = config.replace(/^[-+]/, '');
        const /** @type {?} */ asc = sign !== '-';
        return [prop, asc, sign];
    }
}
OrderByPipe.decorators = [
    { type: Pipe, args: [{ name: 'orderBy' },] },
];
/**
 * @nocollapse
 */
OrderByPipe.ctorParameters = () => [];

class GroupByImpurePipe extends GroupByPipe {
}
GroupByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'groupByImpure', pure: false },] },
];
/**
 * @nocollapse
 */
GroupByImpurePipe.ctorParameters = () => [];

class FilterByImpurePipe extends FilterByPipe {
}
FilterByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'filterByImpure', pure: false },] },
];
/**
 * @nocollapse
 */
FilterByImpurePipe.ctorParameters = () => [];

class OrderByImpurePipe extends OrderByPipe {
}
OrderByImpurePipe.decorators = [
    { type: Pipe, args: [{ name: 'orderByImpure', pure: false },] },
];
/**
 * @nocollapse
 */
OrderByImpurePipe.ctorParameters = () => [];

class RangePipe {
    /**
     * @param {?=} start
     * @param {?=} count
     * @param {?=} step
     * @return {?}
     */
    transform(start = 1, count = 0, step = 1) {
        return Array(count).fill('').map((v, i) => step * i + start);
    }
}
RangePipe.decorators = [
    { type: Pipe, args: [{ name: 'range' },] },
];
/**
 * @nocollapse
 */
RangePipe.ctorParameters = () => [];

const ARRAY_PIPES = [
    DiffPipe, FlattenPipe, InitialPipe, IntersectionPipe, ReversePipe, TailPipe,
    TrurthifyPipe, UnionPipe, UniquePipe, WithoutPipe, PluckPipe, ShufflePipe,
    EveryPipe, SomePipe, SamplePipe, GroupByPipe, GroupByImpurePipe,
    FilterByPipe, FilterByImpurePipe, OrderByPipe, OrderByImpurePipe,
    RangePipe,
];
class NgArrayPipesModule {
}
NgArrayPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: ARRAY_PIPES,
                imports: [],
                exports: ARRAY_PIPES
            },] },
];
/**
 * @nocollapse
 */
NgArrayPipesModule.ctorParameters = () => [];

class KeysPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj);
    }
}
KeysPipe.decorators = [
    { type: Pipe, args: [{ name: 'keys' },] },
];
/**
 * @nocollapse
 */
KeysPipe.ctorParameters = () => [];

class ValuesPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).map(k => obj[k]);
    }
}
ValuesPipe.decorators = [
    { type: Pipe, args: [{ name: 'values' },] },
];
/**
 * @nocollapse
 */
ValuesPipe.ctorParameters = () => [];

class PairsPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).map(k => [k, obj[k]]);
    }
}
PairsPipe.decorators = [
    { type: Pipe, args: [{ name: 'pairs' },] },
];
/**
 * @nocollapse
 */
PairsPipe.ctorParameters = () => [];

class PickPipe {
    /**
     * @param {?} obj
     * @param {...?} args
     * @return {?}
     */
    transform(obj, ...args) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return args.reduce((o, k) => {
            return Object.assign(o, { [k]: obj[k] });
        }, {});
    }
}
PickPipe.decorators = [
    { type: Pipe, args: [{ name: 'pick' },] },
];
/**
 * @nocollapse
 */
PickPipe.ctorParameters = () => [];

class OmitPipe {
    /**
     * @param {?} obj
     * @param {...?} args
     * @return {?}
     */
    transform(obj, ...args) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj)
            .filter(k => !~args.indexOf(k))
            .reduce((o, k) => {
            return Object.assign(o, { [k]: obj[k] });
        }, {});
    }
}
OmitPipe.decorators = [
    { type: Pipe, args: [{ name: 'omit' },] },
];
/**
 * @nocollapse
 */
OmitPipe.ctorParameters = () => [];

class InvertPipe {
    /**
     * @param {?} obj
     * @return {?}
     */
    transform(obj) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj)
            .reduce((o, k) => {
            return Object.assign(o, { [obj[k]]: k });
        }, {});
    }
}
InvertPipe.decorators = [
    { type: Pipe, args: [{ name: 'invert' },] },
];
/**
 * @nocollapse
 */
InvertPipe.ctorParameters = () => [];

class InvertByPipe {
    /**
     * @param {?} obj
     * @param {?=} cb
     * @return {?}
     */
    transform(obj, cb) {
        if (Array.isArray(obj) || !isObject(obj)) {
            return obj;
        }
        return Object.keys(obj).reduce((o, k) => {
            const /** @type {?} */ key = cb ? cb(obj[k]) : obj[k];
            return Array.isArray(o[key])
                ? (o[key].push(k), o)
                : Object.assign(o, { [key]: [k] });
        }, {});
    }
}
InvertByPipe.decorators = [
    { type: Pipe, args: [{ name: 'invertBy' },] },
];
/**
 * @nocollapse
 */
InvertByPipe.ctorParameters = () => [];

class DiffObjPipe {
    /**
     * @param {?} obj
     * @param {?=} original
     * @return {?}
     */
    transform(obj, original = {}) {
        if (Array.isArray(obj) || Array.isArray(original) || !isObject(obj) || !isObject(original)) {
            return {};
        }
        return getKeysTwoObjects(obj, original).reduce((diff, key) => {
            if (!isDeepEqual(original[key], obj[key])) {
                diff[key] = obj[key];
            }
            return diff;
        }, {});
    }
}
DiffObjPipe.decorators = [
    { type: Pipe, args: [{ name: 'diffObj' },] },
];
/**
 * @nocollapse
 */
DiffObjPipe.ctorParameters = () => [];

const OBJECT_PIPES = [
    KeysPipe, ValuesPipe, PairsPipe, PickPipe, InvertPipe, InvertByPipe,
    OmitPipe, DiffObjPipe,
];
class NgObjectPipesModule {
}
NgObjectPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: OBJECT_PIPES,
                imports: [],
                exports: OBJECT_PIPES
            },] },
];
/**
 * @nocollapse
 */
NgObjectPipesModule.ctorParameters = () => [];

class UcWordsPipe {
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        if (isString(text)) {
            return text.split(' ')
                .map((sub) => sub.slice(0, 1).toUpperCase() + sub.slice(1))
                .join(' ');
        }
        return text;
    }
}
UcWordsPipe.decorators = [
    { type: Pipe, args: [{ name: 'ucwords' },] },
];
/**
 * @nocollapse
 */
UcWordsPipe.ctorParameters = () => [];

class LeftTrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.replace(new RegExp(`^[${chars}]+`), '')
            : text;
    }
}
LeftTrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'ltrim' },] },
];
/**
 * @nocollapse
 */
LeftTrimPipe.ctorParameters = () => [];

class RepeatPipe {
    /**
     * @param {?} str
     * @param {?=} n
     * @param {?=} separator
     * @return {?}
     */
    transform(str, n = 1, separator = '') {
        if (n <= 0) {
            throw new RangeError();
        }
        return n === 1 ? str : this.repeat(str, n - 1, separator);
    }
    /**
     * @param {?} str
     * @param {?} n
     * @param {?} separator
     * @return {?}
     */
    repeat(str, n, separator) {
        return isString(str)
            ? (n === 0 ? str : (str + separator + this.repeat(str, n - 1, separator)))
            : str;
    }
}
RepeatPipe.decorators = [
    { type: Pipe, args: [{ name: 'repeat' },] },
];
/**
 * @nocollapse
 */
RepeatPipe.ctorParameters = () => [];

class RightTrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.replace(new RegExp(`[${chars}]+$`), '')
            : text;
    }
}
RightTrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'rtrim' },] },
];
/**
 * @nocollapse
 */
RightTrimPipe.ctorParameters = () => [];

class ScanPipe {
    /**
     * @param {?} text
     * @param {?=} args
     * @return {?}
     */
    transform(text, args = []) {
        return isString(text)
            ? text.replace(/\{(\d+)}/g, (match, index) => !isUndefined(args[index]) ? args[index] : match)
            : text;
    }
}
ScanPipe.decorators = [
    { type: Pipe, args: [{ name: 'scan' },] },
];
/**
 * @nocollapse
 */
ScanPipe.ctorParameters = () => [];

class ShortenPipe {
    /**
     * @param {?} text
     * @param {?=} length
     * @param {?=} suffix
     * @param {?=} wordBreak
     * @return {?}
     */
    transform(text, length = 0, suffix = '', wordBreak = true) {
        if (!isString(text)) {
            return text;
        }
        if (text.length > length) {
            if (wordBreak) {
                return text.slice(0, length) + suffix;
            }
            // tslint:disable-next-line:no-bitwise
            if (!!~text.indexOf(' ', length)) {
                return text.slice(0, text.indexOf(' ', length)) + suffix;
            }
        }
        return text;
    }
}
ShortenPipe.decorators = [
    { type: Pipe, args: [{ name: 'shorten' },] },
];
/**
 * @nocollapse
 */
ShortenPipe.ctorParameters = () => [];

class StripTagsPipe {
    /**
     * @param {?} text
     * @param {...?} allowedTags
     * @return {?}
     */
    transform(text, ...allowedTags) {
        return allowedTags.length > 0
            ? text.replace(new RegExp(`<(?!\/?(${allowedTags.join('|')})\s*\/?)[^>]+>`, 'g'), '')
            : text.replace(/<(?:.|\s)*?>/g, '');
    }
}
StripTagsPipe.decorators = [
    { type: Pipe, args: [{ name: 'stripTags' },] },
];
/**
 * @nocollapse
 */
StripTagsPipe.ctorParameters = () => [];

class TrimPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text) ? text.replace(new RegExp(`^[${chars}]+|[${chars}]+$`, 'g'), '') : text;
    }
}
TrimPipe.decorators = [
    { type: Pipe, args: [{ name: 'trim' },] },
];
/**
 * @nocollapse
 */
TrimPipe.ctorParameters = () => [];

class UcFirstPipe {
    /**
     * @param {?} text
     * @return {?}
     */
    transform(text) {
        return isString(text)
            ? (text.slice(0, 1).toUpperCase() + text.slice(1))
            : text;
    }
}
UcFirstPipe.decorators = [
    { type: Pipe, args: [{ name: 'ucfirst' },] },
];
/**
 * @nocollapse
 */
UcFirstPipe.ctorParameters = () => [];

class SlugifyPipe {
    /**
     * @param {?} str
     * @return {?}
     */
    transform(str) {
        return isString(str)
            ? str.toLowerCase().trim()
                .replace(/[^\w\-]+/g, ' ')
                .replace(/\s+/g, '-')
            : str;
    }
}
SlugifyPipe.decorators = [
    { type: Pipe, args: [{ name: 'slugify' },] },
];
/**
 * @nocollapse
 */
SlugifyPipe.ctorParameters = () => [];

class CamelizePipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        if (!isString(text)) {
            return text;
        }
        return text.toLowerCase()
            .split(/[-_\s]/g)
            .filter((v) => !!v).map((word, key) => {
            return !key ? word : (word.slice(0, 1).toUpperCase() + word.slice(1));
        }).join('');
    }
}
CamelizePipe.decorators = [
    { type: Pipe, args: [{ name: 'camelize' },] },
];
/**
 * @nocollapse
 */
CamelizePipe.ctorParameters = () => [];

class LatinisePipe {
    constructor() {
        this.latinMap = { 'Á': 'A', 'Ă': 'A', 'Ắ': 'A', 'Ặ': 'A', 'Ằ': 'A', 'Ẳ': 'A', 'Ẵ': 'A', 'Ǎ': 'A', 'Â': 'A', 'Ấ': 'A', 'Ậ': 'A', 'Ầ': 'A', 'Ẩ': 'A', 'Ẫ': 'A', 'Ä': 'A', 'Ǟ': 'A', 'Ȧ': 'A', 'Ǡ': 'A', 'Ạ': 'A', 'Ȁ': 'A', 'À': 'A', 'Ả': 'A', 'Ȃ': 'A', 'Ā': 'A', 'Ą': 'A', 'Å': 'A', 'Ǻ': 'A', 'Ḁ': 'A', 'Ⱥ': 'A', 'Ã': 'A', 'Ꜳ': 'AA', 'Æ': 'AE', 'Ǽ': 'AE', 'Ǣ': 'AE', 'Ꜵ': 'AO', 'Ꜷ': 'AU', 'Ꜹ': 'AV', 'Ꜻ': 'AV', 'Ꜽ': 'AY', 'Ḃ': 'B', 'Ḅ': 'B', 'Ɓ': 'B', 'Ḇ': 'B', 'Ƀ': 'B', 'Ƃ': 'B', 'Ć': 'C', 'Č': 'C', 'Ç': 'C', 'Ḉ': 'C', 'Ĉ': 'C', 'Ċ': 'C', 'Ƈ': 'C', 'Ȼ': 'C', 'Ď': 'D', 'Ḑ': 'D', 'Ḓ': 'D', 'Ḋ': 'D', 'Ḍ': 'D', 'Ɗ': 'D', 'Ḏ': 'D', 'ǲ': 'D', 'ǅ': 'D', 'Đ': 'D', 'Ƌ': 'D', 'Ǳ': 'DZ', 'Ǆ': 'DZ', 'É': 'E', 'Ĕ': 'E', 'Ě': 'E', 'Ȩ': 'E', 'Ḝ': 'E', 'Ê': 'E', 'Ế': 'E', 'Ệ': 'E', 'Ề': 'E', 'Ể': 'E', 'Ễ': 'E', 'Ḙ': 'E', 'Ë': 'E', 'Ė': 'E', 'Ẹ': 'E', 'Ȅ': 'E', 'È': 'E', 'Ẻ': 'E', 'Ȇ': 'E', 'Ē': 'E', 'Ḗ': 'E', 'Ḕ': 'E', 'Ę': 'E', 'Ɇ': 'E', 'Ẽ': 'E', 'Ḛ': 'E', 'Ꝫ': 'ET', 'Ḟ': 'F', 'Ƒ': 'F', 'Ǵ': 'G', 'Ğ': 'G', 'Ǧ': 'G', 'Ģ': 'G', 'Ĝ': 'G', 'Ġ': 'G', 'Ɠ': 'G', 'Ḡ': 'G', 'Ǥ': 'G', 'Ḫ': 'H', 'Ȟ': 'H', 'Ḩ': 'H', 'Ĥ': 'H', 'Ⱨ': 'H', 'Ḧ': 'H', 'Ḣ': 'H', 'Ḥ': 'H', 'Ħ': 'H', 'Í': 'I', 'Ĭ': 'I', 'Ǐ': 'I', 'Î': 'I', 'Ï': 'I', 'Ḯ': 'I', 'İ': 'I', 'Ị': 'I', 'Ȉ': 'I', 'Ì': 'I', 'Ỉ': 'I', 'Ȋ': 'I', 'Ī': 'I', 'Į': 'I', 'Ɨ': 'I', 'Ĩ': 'I', 'Ḭ': 'I', 'Ꝺ': 'D', 'Ꝼ': 'F', 'Ᵹ': 'G', 'Ꞃ': 'R', 'Ꞅ': 'S', 'Ꞇ': 'T', 'Ꝭ': 'IS', 'Ĵ': 'J', 'Ɉ': 'J', 'Ḱ': 'K', 'Ǩ': 'K', 'Ķ': 'K', 'Ⱪ': 'K', 'Ꝃ': 'K', 'Ḳ': 'K', 'Ƙ': 'K', 'Ḵ': 'K', 'Ꝁ': 'K', 'Ꝅ': 'K', 'Ĺ': 'L', 'Ƚ': 'L', 'Ľ': 'L', 'Ļ': 'L', 'Ḽ': 'L', 'Ḷ': 'L', 'Ḹ': 'L', 'Ⱡ': 'L', 'Ꝉ': 'L', 'Ḻ': 'L', 'Ŀ': 'L', 'Ɫ': 'L', 'ǈ': 'L', 'Ł': 'L', 'Ǉ': 'LJ', 'Ḿ': 'M', 'Ṁ': 'M', 'Ṃ': 'M', 'Ɱ': 'M', 'Ń': 'N', 'Ň': 'N', 'Ņ': 'N', 'Ṋ': 'N', 'Ṅ': 'N', 'Ṇ': 'N', 'Ǹ': 'N', 'Ɲ': 'N', 'Ṉ': 'N', 'Ƞ': 'N', 'ǋ': 'N', 'Ñ': 'N', 'Ǌ': 'NJ', 'Ó': 'O', 'Ŏ': 'O', 'Ǒ': 'O', 'Ô': 'O', 'Ố': 'O', 'Ộ': 'O', 'Ồ': 'O', 'Ổ': 'O', 'Ỗ': 'O', 'Ö': 'O', 'Ȫ': 'O', 'Ȯ': 'O', 'Ȱ': 'O', 'Ọ': 'O', 'Ő': 'O', 'Ȍ': 'O', 'Ò': 'O', 'Ỏ': 'O', 'Ơ': 'O', 'Ớ': 'O', 'Ợ': 'O', 'Ờ': 'O', 'Ở': 'O', 'Ỡ': 'O', 'Ȏ': 'O', 'Ꝋ': 'O', 'Ꝍ': 'O', 'Ō': 'O', 'Ṓ': 'O', 'Ṑ': 'O', 'Ɵ': 'O', 'Ǫ': 'O', 'Ǭ': 'O', 'Ø': 'O', 'Ǿ': 'O', 'Õ': 'O', 'Ṍ': 'O', 'Ṏ': 'O', 'Ȭ': 'O', 'Ƣ': 'OI', 'Ꝏ': 'OO', 'Ɛ': 'E', 'Ɔ': 'O', 'Ȣ': 'OU', 'Ṕ': 'P', 'Ṗ': 'P', 'Ꝓ': 'P', 'Ƥ': 'P', 'Ꝕ': 'P', 'Ᵽ': 'P', 'Ꝑ': 'P', 'Ꝙ': 'Q', 'Ꝗ': 'Q', 'Ŕ': 'R', 'Ř': 'R', 'Ŗ': 'R', 'Ṙ': 'R', 'Ṛ': 'R', 'Ṝ': 'R', 'Ȑ': 'R', 'Ȓ': 'R', 'Ṟ': 'R', 'Ɍ': 'R', 'Ɽ': 'R', 'Ꜿ': 'C', 'Ǝ': 'E', 'Ś': 'S', 'Ṥ': 'S', 'Š': 'S', 'Ṧ': 'S', 'Ş': 'S', 'Ŝ': 'S', 'Ș': 'S', 'Ṡ': 'S', 'Ṣ': 'S', 'Ṩ': 'S', 'ẞ': 'SS', 'Ť': 'T', 'Ţ': 'T', 'Ṱ': 'T', 'Ț': 'T', 'Ⱦ': 'T', 'Ṫ': 'T', 'Ṭ': 'T', 'Ƭ': 'T', 'Ṯ': 'T', 'Ʈ': 'T', 'Ŧ': 'T', 'Ɐ': 'A', 'Ꞁ': 'L', 'Ɯ': 'M', 'Ʌ': 'V', 'Ꜩ': 'TZ', 'Ú': 'U', 'Ŭ': 'U', 'Ǔ': 'U', 'Û': 'U', 'Ṷ': 'U', 'Ü': 'U', 'Ǘ': 'U', 'Ǚ': 'U', 'Ǜ': 'U', 'Ǖ': 'U', 'Ṳ': 'U', 'Ụ': 'U', 'Ű': 'U', 'Ȕ': 'U', 'Ù': 'U', 'Ủ': 'U', 'Ư': 'U', 'Ứ': 'U', 'Ự': 'U', 'Ừ': 'U', 'Ử': 'U', 'Ữ': 'U', 'Ȗ': 'U', 'Ū': 'U', 'Ṻ': 'U', 'Ų': 'U', 'Ů': 'U', 'Ũ': 'U', 'Ṹ': 'U', 'Ṵ': 'U', 'Ꝟ': 'V', 'Ṿ': 'V', 'Ʋ': 'V', 'Ṽ': 'V', 'Ꝡ': 'VY', 'Ẃ': 'W', 'Ŵ': 'W', 'Ẅ': 'W', 'Ẇ': 'W', 'Ẉ': 'W', 'Ẁ': 'W', 'Ⱳ': 'W', 'Ẍ': 'X', 'Ẋ': 'X', 'Ý': 'Y', 'Ŷ': 'Y', 'Ÿ': 'Y', 'Ẏ': 'Y', 'Ỵ': 'Y', 'Ỳ': 'Y', 'Ƴ': 'Y', 'Ỷ': 'Y', 'Ỿ': 'Y', 'Ȳ': 'Y', 'Ɏ': 'Y', 'Ỹ': 'Y', 'Ź': 'Z', 'Ž': 'Z', 'Ẑ': 'Z', 'Ⱬ': 'Z', 'Ż': 'Z', 'Ẓ': 'Z', 'Ȥ': 'Z', 'Ẕ': 'Z', 'Ƶ': 'Z', 'Ĳ': 'IJ', 'Œ': 'OE', 'ᴀ': 'A', 'ᴁ': 'AE', 'ʙ': 'B', 'ᴃ': 'B', 'ᴄ': 'C', 'ᴅ': 'D', 'ᴇ': 'E', 'ꜰ': 'F', 'ɢ': 'G', 'ʛ': 'G', 'ʜ': 'H', 'ɪ': 'I', 'ʁ': 'R', 'ᴊ': 'J', 'ᴋ': 'K', 'ʟ': 'L', 'ᴌ': 'L', 'ᴍ': 'M', 'ɴ': 'N', 'ᴏ': 'O', 'ɶ': 'OE', 'ᴐ': 'O', 'ᴕ': 'OU', 'ᴘ': 'P', 'ʀ': 'R', 'ᴎ': 'N', 'ᴙ': 'R', 'ꜱ': 'S', 'ᴛ': 'T', 'ⱻ': 'E', 'ᴚ': 'R', 'ᴜ': 'U', 'ᴠ': 'V', 'ᴡ': 'W', 'ʏ': 'Y', 'ᴢ': 'Z', 'á': 'a', 'ă': 'a', 'ắ': 'a', 'ặ': 'a', 'ằ': 'a', 'ẳ': 'a', 'ẵ': 'a', 'ǎ': 'a', 'â': 'a', 'ấ': 'a', 'ậ': 'a', 'ầ': 'a', 'ẩ': 'a', 'ẫ': 'a', 'ä': 'a', 'ǟ': 'a', 'ȧ': 'a', 'ǡ': 'a', 'ạ': 'a', 'ȁ': 'a', 'à': 'a', 'ả': 'a', 'ȃ': 'a', 'ā': 'a', 'ą': 'a', 'ᶏ': 'a', 'ẚ': 'a', 'å': 'a', 'ǻ': 'a', 'ḁ': 'a', 'ⱥ': 'a', 'ã': 'a', 'ꜳ': 'aa', 'æ': 'ae', 'ǽ': 'ae', 'ǣ': 'ae', 'ꜵ': 'ao', 'ꜷ': 'au', 'ꜹ': 'av', 'ꜻ': 'av', 'ꜽ': 'ay', 'ḃ': 'b', 'ḅ': 'b', 'ɓ': 'b', 'ḇ': 'b', 'ᵬ': 'b', 'ᶀ': 'b', 'ƀ': 'b', 'ƃ': 'b', 'ɵ': 'o', 'ć': 'c', 'č': 'c', 'ç': 'c', 'ḉ': 'c', 'ĉ': 'c', 'ɕ': 'c', 'ċ': 'c', 'ƈ': 'c', 'ȼ': 'c', 'ď': 'd', 'ḑ': 'd', 'ḓ': 'd', 'ȡ': 'd', 'ḋ': 'd', 'ḍ': 'd', 'ɗ': 'd', 'ᶑ': 'd', 'ḏ': 'd', 'ᵭ': 'd', 'ᶁ': 'd', 'đ': 'd', 'ɖ': 'd', 'ƌ': 'd', 'ı': 'i', 'ȷ': 'j', 'ɟ': 'j', 'ʄ': 'j', 'ǳ': 'dz', 'ǆ': 'dz', 'é': 'e', 'ĕ': 'e', 'ě': 'e', 'ȩ': 'e', 'ḝ': 'e', 'ê': 'e', 'ế': 'e', 'ệ': 'e', 'ề': 'e', 'ể': 'e', 'ễ': 'e', 'ḙ': 'e', 'ë': 'e', 'ė': 'e', 'ẹ': 'e', 'ȅ': 'e', 'è': 'e', 'ẻ': 'e', 'ȇ': 'e', 'ē': 'e', 'ḗ': 'e', 'ḕ': 'e', 'ⱸ': 'e', 'ę': 'e', 'ᶒ': 'e', 'ɇ': 'e', 'ẽ': 'e', 'ḛ': 'e', 'ꝫ': 'et', 'ḟ': 'f', 'ƒ': 'f', 'ᵮ': 'f', 'ᶂ': 'f', 'ǵ': 'g', 'ğ': 'g', 'ǧ': 'g', 'ģ': 'g', 'ĝ': 'g', 'ġ': 'g', 'ɠ': 'g', 'ḡ': 'g', 'ᶃ': 'g', 'ǥ': 'g', 'ḫ': 'h', 'ȟ': 'h', 'ḩ': 'h', 'ĥ': 'h', 'ⱨ': 'h', 'ḧ': 'h', 'ḣ': 'h', 'ḥ': 'h', 'ɦ': 'h', 'ẖ': 'h', 'ħ': 'h', 'ƕ': 'hv', 'í': 'i', 'ĭ': 'i', 'ǐ': 'i', 'î': 'i', 'ï': 'i', 'ḯ': 'i', 'ị': 'i', 'ȉ': 'i', 'ì': 'i', 'ỉ': 'i', 'ȋ': 'i', 'ī': 'i', 'į': 'i', 'ᶖ': 'i', 'ɨ': 'i', 'ĩ': 'i', 'ḭ': 'i', 'ꝺ': 'd', 'ꝼ': 'f', 'ᵹ': 'g', 'ꞃ': 'r', 'ꞅ': 's', 'ꞇ': 't', 'ꝭ': 'is', 'ǰ': 'j', 'ĵ': 'j', 'ʝ': 'j', 'ɉ': 'j', 'ḱ': 'k', 'ǩ': 'k', 'ķ': 'k', 'ⱪ': 'k', 'ꝃ': 'k', 'ḳ': 'k', 'ƙ': 'k', 'ḵ': 'k', 'ᶄ': 'k', 'ꝁ': 'k', 'ꝅ': 'k', 'ĺ': 'l', 'ƚ': 'l', 'ɬ': 'l', 'ľ': 'l', 'ļ': 'l', 'ḽ': 'l', 'ȴ': 'l', 'ḷ': 'l', 'ḹ': 'l', 'ⱡ': 'l', 'ꝉ': 'l', 'ḻ': 'l', 'ŀ': 'l', 'ɫ': 'l', 'ᶅ': 'l', 'ɭ': 'l', 'ł': 'l', 'ǉ': 'lj', 'ſ': 's', 'ẜ': 's', 'ẛ': 's', 'ẝ': 's', 'ḿ': 'm', 'ṁ': 'm', 'ṃ': 'm', 'ɱ': 'm', 'ᵯ': 'm', 'ᶆ': 'm', 'ń': 'n', 'ň': 'n', 'ņ': 'n', 'ṋ': 'n', 'ȵ': 'n', 'ṅ': 'n', 'ṇ': 'n', 'ǹ': 'n', 'ɲ': 'n', 'ṉ': 'n', 'ƞ': 'n', 'ᵰ': 'n', 'ᶇ': 'n', 'ɳ': 'n', 'ñ': 'n', 'ǌ': 'nj', 'ó': 'o', 'ŏ': 'o', 'ǒ': 'o', 'ô': 'o', 'ố': 'o', 'ộ': 'o', 'ồ': 'o', 'ổ': 'o', 'ỗ': 'o', 'ö': 'o', 'ȫ': 'o', 'ȯ': 'o', 'ȱ': 'o', 'ọ': 'o', 'ő': 'o', 'ȍ': 'o', 'ò': 'o', 'ỏ': 'o', 'ơ': 'o', 'ớ': 'o', 'ợ': 'o', 'ờ': 'o', 'ở': 'o', 'ỡ': 'o', 'ȏ': 'o', 'ꝋ': 'o', 'ꝍ': 'o', 'ⱺ': 'o', 'ō': 'o', 'ṓ': 'o', 'ṑ': 'o', 'ǫ': 'o', 'ǭ': 'o', 'ø': 'o', 'ǿ': 'o', 'õ': 'o', 'ṍ': 'o', 'ṏ': 'o', 'ȭ': 'o', 'ƣ': 'oi', 'ꝏ': 'oo', 'ɛ': 'e', 'ᶓ': 'e', 'ɔ': 'o', 'ᶗ': 'o', 'ȣ': 'ou', 'ṕ': 'p', 'ṗ': 'p', 'ꝓ': 'p', 'ƥ': 'p', 'ᵱ': 'p', 'ᶈ': 'p', 'ꝕ': 'p', 'ᵽ': 'p', 'ꝑ': 'p', 'ꝙ': 'q', 'ʠ': 'q', 'ɋ': 'q', 'ꝗ': 'q', 'ŕ': 'r', 'ř': 'r', 'ŗ': 'r', 'ṙ': 'r', 'ṛ': 'r', 'ṝ': 'r', 'ȑ': 'r', 'ɾ': 'r', 'ᵳ': 'r', 'ȓ': 'r', 'ṟ': 'r', 'ɼ': 'r', 'ᵲ': 'r', 'ᶉ': 'r', 'ɍ': 'r', 'ɽ': 'r', 'ↄ': 'c', 'ꜿ': 'c', 'ɘ': 'e', 'ɿ': 'r', 'ś': 's', 'ṥ': 's', 'š': 's', 'ṧ': 's', 'ş': 's', 'ŝ': 's', 'ș': 's', 'ṡ': 's', 'ṣ': 's', 'ṩ': 's', 'ʂ': 's', 'ᵴ': 's', 'ᶊ': 's', 'ȿ': 's', 'ɡ': 'g', 'ß': 'ss', 'ᴑ': 'o', 'ᴓ': 'o', 'ᴝ': 'u', 'ť': 't', 'ţ': 't', 'ṱ': 't', 'ț': 't', 'ȶ': 't', 'ẗ': 't', 'ⱦ': 't', 'ṫ': 't', 'ṭ': 't', 'ƭ': 't', 'ṯ': 't', 'ᵵ': 't', 'ƫ': 't', 'ʈ': 't', 'ŧ': 't', 'ᵺ': 'th', 'ɐ': 'a', 'ᴂ': 'ae', 'ǝ': 'e', 'ᵷ': 'g', 'ɥ': 'h', 'ʮ': 'h', 'ʯ': 'h', 'ᴉ': 'i', 'ʞ': 'k', 'ꞁ': 'l', 'ɯ': 'm', 'ɰ': 'm', 'ᴔ': 'oe', 'ɹ': 'r', 'ɻ': 'r', 'ɺ': 'r', 'ⱹ': 'r', 'ʇ': 't', 'ʌ': 'v', 'ʍ': 'w', 'ʎ': 'y', 'ꜩ': 'tz', 'ú': 'u', 'ŭ': 'u', 'ǔ': 'u', 'û': 'u', 'ṷ': 'u', 'ü': 'u', 'ǘ': 'u', 'ǚ': 'u', 'ǜ': 'u', 'ǖ': 'u', 'ṳ': 'u', 'ụ': 'u', 'ű': 'u', 'ȕ': 'u', 'ù': 'u', 'ủ': 'u', 'ư': 'u', 'ứ': 'u', 'ự': 'u', 'ừ': 'u', 'ử': 'u', 'ữ': 'u', 'ȗ': 'u', 'ū': 'u', 'ṻ': 'u', 'ų': 'u', 'ᶙ': 'u', 'ů': 'u', 'ũ': 'u', 'ṹ': 'u', 'ṵ': 'u', 'ᵫ': 'ue', 'ꝸ': 'um', 'ⱴ': 'v', 'ꝟ': 'v', 'ṿ': 'v', 'ʋ': 'v', 'ᶌ': 'v', 'ⱱ': 'v', 'ṽ': 'v', 'ꝡ': 'vy', 'ẃ': 'w', 'ŵ': 'w', 'ẅ': 'w', 'ẇ': 'w', 'ẉ': 'w', 'ẁ': 'w', 'ⱳ': 'w', 'ẘ': 'w', 'ẍ': 'x', 'ẋ': 'x', 'ᶍ': 'x', 'ý': 'y', 'ŷ': 'y', 'ÿ': 'y', 'ẏ': 'y', 'ỵ': 'y', 'ỳ': 'y', 'ƴ': 'y', 'ỷ': 'y', 'ỿ': 'y', 'ȳ': 'y', 'ẙ': 'y', 'ɏ': 'y', 'ỹ': 'y', 'ź': 'z', 'ž': 'z', 'ẑ': 'z', 'ʑ': 'z', 'ⱬ': 'z', 'ż': 'z', 'ẓ': 'z', 'ȥ': 'z', 'ẕ': 'z', 'ᵶ': 'z', 'ᶎ': 'z', 'ʐ': 'z', 'ƶ': 'z', 'ɀ': 'z', 'ﬀ': 'ff', 'ﬃ': 'ffi', 'ﬄ': 'ffl', 'ﬁ': 'fi', 'ﬂ': 'fl', 'ĳ': 'ij', 'œ': 'oe', 'ﬆ': 'st', 'ₐ': 'a', 'ₑ': 'e', 'ᵢ': 'i', 'ⱼ': 'j', 'ₒ': 'o', 'ᵣ': 'r', 'ᵤ': 'u', 'ᵥ': 'v', 'ₓ': 'x' };
    }
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.replace(/[^A-Za-z0-9]/g, (key) => {
                return this.latinMap[key] || key;
            }) : text;
    }
}
LatinisePipe.decorators = [
    { type: Pipe, args: [{ name: 'latinise' },] },
];
/**
 * @nocollapse
 */
LatinisePipe.ctorParameters = () => [];

class LinesPipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.replace(/\r\n/g, '\n').split('\n')
            : text;
    }
}
LinesPipe.decorators = [
    { type: Pipe, args: [{ name: 'lines' },] },
];
/**
 * @nocollapse
 */
LinesPipe.ctorParameters = () => [];

class UnderscorePipe {
    /**
     * @param {?} text
     * @param {?=} chars
     * @return {?}
     */
    transform(text, chars = '\\s') {
        return isString(text)
            ? text.trim()
                .replace(/\s+/g, '')
                .replace(/[A-Z]/g, (c, k) => {
                return k ? `_${c.toLowerCase()}` : c.toLowerCase();
            })
            : text;
    }
}
UnderscorePipe.decorators = [
    { type: Pipe, args: [{ name: 'underscore' },] },
];
/**
 * @nocollapse
 */
UnderscorePipe.ctorParameters = () => [];

class MatchPipe {
    /**
     * @param {?} text
     * @param {?} pattern
     * @param {?=} flags
     * @return {?}
     */
    transform(text, pattern, flags) {
        if (!isString(text)) {
            return text;
        }
        return text.match(new RegExp(pattern, flags));
    }
}
MatchPipe.decorators = [
    { type: Pipe, args: [{ name: 'match' },] },
];
/**
 * @nocollapse
 */
MatchPipe.ctorParameters = () => [];

class TestPipe {
    /**
     * @param {?} text
     * @param {?} pattern
     * @param {?=} flags
     * @return {?}
     */
    transform(text, pattern, flags) {
        if (!isString(text)) {
            return text;
        }
        return (new RegExp(pattern, flags)).test(text);
    }
}
TestPipe.decorators = [
    { type: Pipe, args: [{ name: 'test' },] },
];
/**
 * @nocollapse
 */
TestPipe.ctorParameters = () => [];

class LeftPadPipe {
    /**
     * @param {?} str
     * @param {?} length
     * @param {?=} padCharacter
     * @return {?}
     */
    transform(str, length, padCharacter = ' ') {
        if (!isString(str) || str.length >= length) {
            return str;
        }
        while (str.length < length) {
            str = padCharacter + str;
        }
        return str;
    }
}
LeftPadPipe.decorators = [
    { type: Pipe, args: [{ name: 'lpad' },] },
];
/**
 * @nocollapse
 */
LeftPadPipe.ctorParameters = () => [];

class RightPadPipe {
    /**
     * @param {?} str
     * @param {?=} length
     * @param {?=} padCharacter
     * @return {?}
     */
    transform(str, length = 1, padCharacter = ' ') {
        if (!isString(str) || str.length >= length) {
            return str;
        }
        while (str.length < length) {
            str = str + padCharacter;
        }
        return str;
    }
}
RightPadPipe.decorators = [
    { type: Pipe, args: [{ name: 'rpad' },] },
];
/**
 * @nocollapse
 */
RightPadPipe.ctorParameters = () => [];

const STRING_PIPES = [
    LeftTrimPipe, RepeatPipe, RightTrimPipe, ScanPipe, ShortenPipe,
    StripTagsPipe, TrimPipe, UcFirstPipe, UcWordsPipe, SlugifyPipe,
    CamelizePipe, LatinisePipe, LinesPipe, UnderscorePipe, MatchPipe,
    TestPipe, LeftPadPipe, RightPadPipe,
];
class NgStringPipesModule {
}
NgStringPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: STRING_PIPES,
                imports: [],
                exports: STRING_PIPES
            },] },
];
/**
 * @nocollapse
 */
NgStringPipesModule.ctorParameters = () => [];

class MaxPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr)
            ? Math.max(...arr)
            : arr;
    }
}
MaxPipe.decorators = [
    { type: Pipe, args: [{ name: 'max' },] },
];
/**
 * @nocollapse
 */
MaxPipe.ctorParameters = () => [];

class MinPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr)
            ? Math.min(...arr)
            : arr;
    }
}
MinPipe.decorators = [
    { type: Pipe, args: [{ name: 'min' },] },
];
/**
 * @nocollapse
 */
MinPipe.ctorParameters = () => [];

class PercentagePipe {
    /**
     * @param {?} num
     * @param {?=} total
     * @param {?=} floor
     * @return {?}
     */
    transform(num, total = 100, floor = false) {
        if (isNaN(num)) {
            return num;
        }
        const /** @type {?} */ percent = num * 100 / total;
        return floor ? Math.floor(percent) : percent;
    }
}
PercentagePipe.decorators = [
    { type: Pipe, args: [{ name: 'percentage' },] },
];
/**
 * @nocollapse
 */
PercentagePipe.ctorParameters = () => [];

class SumPipe {
    /**
     * @param {?} arr
     * @return {?}
     */
    transform(arr) {
        return Array.isArray(arr)
            ? arr.reduce((sum, curr) => sum + curr, 0)
            : arr;
    }
}
SumPipe.decorators = [
    { type: Pipe, args: [{ name: 'sum' },] },
];
/**
 * @nocollapse
 */
SumPipe.ctorParameters = () => [];

class FloorPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        if (precision <= 0) {
            return Math.floor(num);
        }
        const /** @type {?} */ tho = Math.pow(10, precision);
        return Math.floor(num * tho) / tho;
    }
}
FloorPipe.decorators = [
    { type: Pipe, args: [{ name: 'floor' },] },
];
/**
 * @nocollapse
 */
FloorPipe.ctorParameters = () => [];

class RoundPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        return applyPrecision(num, precision);
    }
}
RoundPipe.decorators = [
    { type: Pipe, args: [{ name: 'round' },] },
];
/**
 * @nocollapse
 */
RoundPipe.ctorParameters = () => [];

class SqrtPipe {
    /**
     * @param {?} num
     * @return {?}
     */
    transform(num) {
        return !isNaN(num)
            ? Math.sqrt(num)
            : num;
    }
}
SqrtPipe.decorators = [
    { type: Pipe, args: [{ name: 'sqrt' },] },
];
/**
 * @nocollapse
 */
SqrtPipe.ctorParameters = () => [];

class PowerPipe {
    /**
     * @param {?} num
     * @param {?=} power
     * @return {?}
     */
    transform(num, power = 2) {
        return !isNaN(num)
            ? Math.pow(num, power)
            : num;
    }
}
PowerPipe.decorators = [
    { type: Pipe, args: [{ name: 'pow' },] },
];
/**
 * @nocollapse
 */
PowerPipe.ctorParameters = () => [];

class CeilPipe {
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    transform(num, precision = 0) {
        if (precision <= 0) {
            return Math.ceil(num);
        }
        const /** @type {?} */ tho = Math.pow(10, precision);
        return Math.ceil(num * tho) / tho;
    }
}
CeilPipe.decorators = [
    { type: Pipe, args: [{ name: 'ceil' },] },
];
/**
 * @nocollapse
 */
CeilPipe.ctorParameters = () => [];

class DegreesPipe {
    /**
     * @param {?} radians
     * @return {?}
     */
    transform(radians) {
        if (!isNumberFinite(radians)) {
            return NaN;
        }
        return radians * 180 / Math.PI;
    }
}
DegreesPipe.decorators = [
    { type: Pipe, args: [{ name: 'degrees' },] },
];
/**
 * @nocollapse
 */
DegreesPipe.ctorParameters = () => [];

class BytesPipe {
    constructor() {
        this.dictionary = [
            { max: 1024, type: 'B' },
            { max: 1048576, type: 'KB' },
            { max: 1073741824, type: 'MB' },
            { max: 1.0995116e12, type: 'GB' },
        ];
    }
    /**
     * @param {?} value
     * @param {?=} precision
     * @return {?}
     */
    transform(value, precision) {
        if (!isNumberFinite(value)) {
            return NaN;
        }
        const /** @type {?} */ format = this.dictionary.find(d => value < d.max) || this.dictionary[this.dictionary.length - 1];
        const /** @type {?} */ calc = value / (format.max / 1024);
        const /** @type {?} */ num = isUndefined(precision) ? calc : applyPrecision(calc, precision);
        return `${num} ${format.type}`;
    }
}
BytesPipe.decorators = [
    { type: Pipe, args: [{ name: 'bytes' },] },
];
/**
 * @nocollapse
 */
BytesPipe.ctorParameters = () => [];

class RadiansPipe {
    /**
     * @param {?} degrees
     * @return {?}
     */
    transform(degrees) {
        if (!isNumberFinite(degrees)) {
            return NaN;
        }
        return degrees * Math.PI / 180;
    }
}
RadiansPipe.decorators = [
    { type: Pipe, args: [{ name: 'radians' },] },
];
/**
 * @nocollapse
 */
RadiansPipe.ctorParameters = () => [];

const MATH_PIPES = [
    MaxPipe, MinPipe, PercentagePipe, SumPipe, FloorPipe, RoundPipe, SqrtPipe, PowerPipe,
    CeilPipe, DegreesPipe, BytesPipe, RadiansPipe,
];
class NgMathPipesModule {
}
NgMathPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: MATH_PIPES,
                imports: [],
                exports: MATH_PIPES
            },] },
];
/**
 * @nocollapse
 */
NgMathPipesModule.ctorParameters = () => [];

class IsDefinedPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return !isUndefined(input);
    }
}
IsDefinedPipe.decorators = [
    { type: Pipe, args: [{ name: 'isDefined' },] },
];
/**
 * @nocollapse
 */
IsDefinedPipe.ctorParameters = () => [];

class IsNullPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return input === null;
    }
}
IsNullPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNull' },] },
];
/**
 * @nocollapse
 */
IsNullPipe.ctorParameters = () => [];

class IsUndefinedPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isUndefined(input);
    }
}
IsUndefinedPipe.decorators = [
    { type: Pipe, args: [{ name: 'isUndefined' },] },
];
/**
 * @nocollapse
 */
IsUndefinedPipe.ctorParameters = () => [];

class IsStringPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isString(input);
    }
}
IsStringPipe.decorators = [
    { type: Pipe, args: [{ name: 'isString' },] },
];
/**
 * @nocollapse
 */
IsStringPipe.ctorParameters = () => [];

class IsFunctionPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isFunction(input);
    }
}
IsFunctionPipe.decorators = [
    { type: Pipe, args: [{ name: 'isFunction' },] },
];
/**
 * @nocollapse
 */
IsFunctionPipe.ctorParameters = () => [];

class IsNumberPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isNumber(input);
    }
}
IsNumberPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNumber' },] },
];
/**
 * @nocollapse
 */
IsNumberPipe.ctorParameters = () => [];

class IsArrayPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return Array.isArray(input);
    }
}
IsArrayPipe.decorators = [
    { type: Pipe, args: [{ name: 'isArray' },] },
];
/**
 * @nocollapse
 */
IsArrayPipe.ctorParameters = () => [];

class IsObjectPipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return isObject(input);
    }
}
IsObjectPipe.decorators = [
    { type: Pipe, args: [{ name: 'isObject' },] },
];
/**
 * @nocollapse
 */
IsObjectPipe.ctorParameters = () => [];

class IsGreaterEqualThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input >= other;
    }
}
IsGreaterEqualThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isGreaterEqualThan' },] },
];
/**
 * @nocollapse
 */
IsGreaterEqualThanPipe.ctorParameters = () => [];

class IsGreaterThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input > other;
    }
}
IsGreaterThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isGreaterThan' },] },
];
/**
 * @nocollapse
 */
IsGreaterThanPipe.ctorParameters = () => [];

class IsLessEqualThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input <= other;
    }
}
IsLessEqualThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isLessEqualThan' },] },
];
/**
 * @nocollapse
 */
IsLessEqualThanPipe.ctorParameters = () => [];

class IsEqualToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        // tslint:disable-next-line:triple-equals
        return input == other;
    }
}
IsEqualToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isEqualTo' },] },
];
/**
 * @nocollapse
 */
IsEqualToPipe.ctorParameters = () => [];

class IsNotEqualToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        // tslint:disable-next-line:triple-equals
        return input != other;
    }
}
IsNotEqualToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNotEqualTo' },] },
];
/**
 * @nocollapse
 */
IsNotEqualToPipe.ctorParameters = () => [];

class IsIdenticalToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input === other;
    }
}
IsIdenticalToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isIdenticalTo' },] },
];
/**
 * @nocollapse
 */
IsIdenticalToPipe.ctorParameters = () => [];

class IsNotIdenticalToPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input !== other;
    }
}
IsNotIdenticalToPipe.decorators = [
    { type: Pipe, args: [{ name: 'isNotIdenticalTo' },] },
];
/**
 * @nocollapse
 */
IsNotIdenticalToPipe.ctorParameters = () => [];

class IsLessThanPipe {
    /**
     * @param {?} input
     * @param {?} other
     * @return {?}
     */
    transform(input, other) {
        return input < other;
    }
}
IsLessThanPipe.decorators = [
    { type: Pipe, args: [{ name: 'isLessThan' },] },
];
/**
 * @nocollapse
 */
IsLessThanPipe.ctorParameters = () => [];

const BOOLEAN_PIPES = [
    IsDefinedPipe, IsNullPipe, IsUndefinedPipe, IsStringPipe, IsFunctionPipe, IsNumberPipe,
    IsArrayPipe, IsObjectPipe, IsGreaterEqualThanPipe, IsGreaterThanPipe, IsLessEqualThanPipe,
    IsLessEqualThanPipe, IsEqualToPipe, IsNotEqualToPipe, IsIdenticalToPipe, IsNotIdenticalToPipe,
    IsLessThanPipe,
];
class NgBooleanPipesModule {
}
NgBooleanPipesModule.decorators = [
    { type: NgModule, args: [{
                declarations: BOOLEAN_PIPES,
                imports: [],
                exports: BOOLEAN_PIPES
            },] },
];
/**
 * @nocollapse
 */
NgBooleanPipesModule.ctorParameters = () => [];

class NgPipesModule {
}
NgPipesModule.decorators = [
    { type: NgModule, args: [{
                exports: [NgArrayPipesModule, NgStringPipesModule, NgMathPipesModule, NgBooleanPipesModule, NgObjectPipesModule]
            },] },
];
/**
 * @nocollapse
 */
NgPipesModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { NgPipesModule, NgArrayPipesModule, DiffPipe, InitialPipe, FlattenPipe, IntersectionPipe, ReversePipe, TailPipe, TrurthifyPipe, UnionPipe, UniquePipe, WithoutPipe, PluckPipe, ShufflePipe, EveryPipe, SomePipe, SamplePipe, GroupByPipe, FilterByPipe, OrderByPipe, GroupByImpurePipe, FilterByImpurePipe, OrderByImpurePipe, RangePipe, NgObjectPipesModule, KeysPipe, ValuesPipe, PairsPipe, PickPipe, OmitPipe, InvertPipe, InvertByPipe, DiffObjPipe, STRING_PIPES, NgStringPipesModule, UcWordsPipe, LeftTrimPipe, RepeatPipe, RightTrimPipe, ScanPipe, ShortenPipe, StripTagsPipe, TrimPipe, UcFirstPipe, SlugifyPipe, CamelizePipe, LatinisePipe, LinesPipe, UnderscorePipe, MatchPipe, TestPipe, LeftPadPipe, RightPadPipe, MATH_PIPES, NgMathPipesModule, MaxPipe, MinPipe, PercentagePipe, SumPipe, FloorPipe, RoundPipe, SqrtPipe, PowerPipe, CeilPipe, DegreesPipe, BytesPipe, BOOLEAN_PIPES, NgBooleanPipesModule, IsDefinedPipe, IsNullPipe, IsUndefinedPipe, IsStringPipe, IsFunctionPipe, IsNumberPipe, IsArrayPipe, IsObjectPipe, IsGreaterEqualThanPipe, IsGreaterThanPipe, IsLessEqualThanPipe, IsEqualToPipe, IsNotEqualToPipe, IsIdenticalToPipe, IsNotIdenticalToPipe, IsLessThanPipe, isString as ɵa, RadiansPipe as ɵb };
//# sourceMappingURL=ngx-pipes.js.map
